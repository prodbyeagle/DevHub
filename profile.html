<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='/SF-Pro.woff2' rel='stylesheet' type='font-face/css'>
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <title>Profil</title>
    <style>
        body {
            font-family: SF Pro Medium, 'Helvetica Neue', sans-serif;
            background-color: #f0f0f0;
            color: #333;
            transition: all 0.3s ease;
        }

        /* Neumorphism styles for Dark Mode */
        body.dark-mode {
            background-color: #222;
            color: #eee;
            transition: all 0.3s ease;
        }

        /* Neumorphism styles for the form */
        .neumorphism-form {
            background-color: #f0f0f0;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        body.dark-mode .neumorphism-form {
            background-color: #222;
            box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
        }

        /* Neumorphism styles for the input fields */
        .neumorphism-input {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }

        body.dark-mode .neumorphism-input {
            border-color: #555;
            background-color: #333;
            color: #eee;
        }

        /* Neumorphism styles for the submit button */
        .neumorphism-button {
            background-color: #007bff;
            color: #fff;
            font-family: SF Pro Medium, 'Helvetica Neue', sans-serif;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1), -4px -4px 8px rgba(255, 255, 255, 0.5);
        }

        .neumorphism-button:hover {
            background-color: #0056b3;
            box-shadow: 0 0 16px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode .neumorphism-button {
            background-color: #222;
            color: #eee;
            font-family: SF Pro Medium, 'Helvetica Neue', sans-serif;
            box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .neumorphism-button:hover {
            background-color: #333;
        }

        /* Dark Mode styles for the checkbox */
        .neumorphism-checkbox {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 1.4em;
            height: 1.4em;
            border: 2px solid #ccc;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .neumorphism-checkbox:checked {
            background-color: #007bff;
            border-color: #007bff;
        }

        /* Custom styles for the switch label */
        .switch-label {
            margin-left: 0.5rem;
            font-size: 0.875rem;
            color: #333;
        }

        /* Dark Mode styles for the switch label */
        body.dark-mode .switch-label {
            color: #eee;
        }

        /* Overlay styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: all 0.3s ease;
        }

        .overlay-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
        }

        /* Hidden class */
        .hidden {
            display: none;
            transition: all 0.3s ease;
        }
        
        .content-container {
            padding: 1rem;
            background-color: #f0f0f0;
            color: #333;
            font-family: SF Pro Medium, 'Helvetica Neue', sans-serif;
            border-radius: 16px;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1), -4px -4px 8px rgba(255, 255, 255, 0.5);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        
        body.dark-mode .content-container {
            padding: 1rem;
            background-color: #222;
            color: #eee;
            border-radius: 16px;
            box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
            margin-bottom: 20px;
            
        }

            /* Neumorphism styles for the posts */
    .post {
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        padding: 1rem;
        margin-bottom: 1rem;
        color: #333;
        border-radius: 16px;
        box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1), -4px -4px 8px rgba(255, 255, 255, 0.5);
        transition: transform 0.3s ease, box-shadow 0.3s ease; /* Hinzugef√ºgt f√ºr Hover-Effekt */
    }

    .post:hover {
        transform: scale(1.02); /* Vergr√∂√üern des Posts beim Hover */
        box-shadow: 0 0 16px rgba(0, 0, 0, 0.1); /* Schatteneffekt beim Hover */
    }

    /* Neumorphism styles for dark mode */
    body.dark-mode .post {
        background-color: #222;
        border: 1px solid #333;
        color: #eee;
        box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
    }

    body.dark-mode .post:hover {
        box-shadow: 0 0 16px rgba(0, 0, 0, 0.5); /* Schatteneffekt beim Hover */
        transform: scale(1.02);
    }

    .scroll-to-top {
            position: fixed;
            bottom: 20px; /* Adjust as needed */
            right: 20px; /* Adjust as needed */
            z-index: 9999;
            display: none; /* Hide by default */
            width: 60px;
            height: 60px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1), -4px -4px 8px rgba(255, 255, 255, 0.5);
        }

        .scroll-to-top:hover {
            background-color: #0056b3;
            box-shadow: 0 0 16px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode .scroll-to-top {
            background-color: #222;
            color: #eee;
            box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .scroll-to-top:hover {
            background-color: #333;
        }

        ::-webkit-scrollbar {
            width: 8px; /* Breite der Scrollleiste */
            transition: width 0.3s ease; /* √úbergangseffekt f√ºr die Breite */
        }

        ::-webkit-scrollbar-track {
            background: transparent; /* Hintergrundfarbe der Scrollleiste */
        }

        ::-webkit-scrollbar-thumb {
            background: #888; /* Farbe des Scrollleisten-Griffs */
            border-radius: 8px; /* Radius der Scrollleisten-Griffkanten */
        }

        /* Neumorphismus-Stil f√ºr den Dark/White Mode Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto py-8 profile-container neumorphism-form">
        <div class="profile-card" id="profile-card">
            <div class="profile-picture">
                <img id="profile-picture" src="" alt="Profile Picture" style="width: 100px; height: 100px; border-radius: 50%;">
            </div>
            <div class="profile-info">
                <h1 class="text-3xl font-bold mb-2" id="profile-username">@<span id="profile-username">Loading...</span></h1>
                <p class="text-gray-600" id="profile-description">Loading...</p>
            </div>
            <div class="follower-section">
                <h2>Follower</h2>
                <p id="follower-count">0</p>
            </div>
            <div class="following-section">
                <h2>Following</h2>
                <p id="following-names"></p>
            </div>
        </div>

        <div class="change-bio">
            <button onclick="showOverlay()" class="neumorphism-button mt-4" style="margin-bottom: 15px;">Update Bio</button>
        </div>

        <div class="file-upload">
            <input type="file" id="profile-picture-upload" accept="image/*" style="display: none;">
            <label for="profile-picture-upload" class="neumorphism-button mt-4" style="margin-bottom: 15px;">Upload Profile Picture</label>
        </div>

    </div>

    <div class="overlay hidden" id="overlay">
        <div class="overlay-content neumorphism-form">
            <h2 class="text-2xl font-semibold mb-4">Change Bio</h2>
            <textarea class="w-full p-2 border border-gray-300 rounded-md mb-4 neumorphism-input"
                style="resize: none; white-space: nowrap; font-family: Font, SF Pro Medium, 'Open Sans', sans-serif;" id="bio-input" placeholder="Type your Bio here." rows="4" cols="32" maxlength="32"></textarea>
            <div class="flex justify-between items-center mb-2">
                <p id="char-count"></p>
                <button type="button" class="neumorphism-button" onclick="saveBio()">Save</button>
            </div>
            <div class="flex justify-end">
                <button type="button" class="neumorphism-button bg-gray-300 text-gray-700 ml-2"
                    onclick="closeOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div class="content-container">
        <div id="user-posts" class="mt-8" style="font-family: SF Pro Medium, 'Ubuntu', Roboto, Oxygen, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">
        </div>
    </div>

    <div class="flex justify-center items-center fixed inset-x-0 bottom-0 mb-8">
        <div class="container mx-auto">
            <a href="/home" class="neumorphism-button text-blue-600">Home</a>
        </div>
    </div>
</body>
<button class="scroll-to-top" onclick="scrollToTop()" title="Go to top">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
    </svg>
</button>
    <script>
        async function fetchUserPosts(username) {
            try {
                const response = await fetch(`/api/${username}/posts`);
                const postsData = await response.json();
                if (postsData.length === 0) {
                    renderNoPostsMessage();
                } else {
                    renderPosts(postsData);
                }
            } catch (error) {
                console.error('Error fetching user posts:', error);
            }
        }
        
        function renderNoPostsMessage() {
            const postsContainer = document.getElementById('user-posts');
            postsContainer.innerHTML = ''; // Clear previous posts
        
            const messageElement = document.createElement('p');
            messageElement.textContent = 'üò≠ No Posts! ...you can make an posts on your /home page';
            postsContainer.appendChild(messageElement);
        }

        function renderPosts(posts) {
        const postsContainer = document.getElementById('user-posts');
        postsContainer.innerHTML = ''; // Clear previous posts

        posts.forEach(post => {
            const postElement = document.createElement('div');
            postElement.classList.add('post', 'p-4', 'rounded', 'shadow', 'mb-4');

            const usernameElement = document.createElement('h3');
            usernameElement.textContent = `@${post.username} (${post.date})`;

            const contentElement = document.createElement('p');
            contentElement.textContent = post.content;

            const codeSnippetElement = document.createElement('pre');
            codeSnippetElement.textContent = post.codesnippet;
            codeSnippetElement.classList.add('bg-gray-800', 'text-white', 'p-4', 'rounded', 'text-xs');
            codeSnippetElement.style.whiteSpace = 'pre-wrap'; // Wrap lines
            codeSnippetElement.style.maxWidth = '100%'; // Set max width

            postElement.appendChild(usernameElement);
            postElement.appendChild(contentElement);
            postElement.appendChild(codeSnippetElement);

            postsContainer.appendChild(postElement);
        });
        }
    
        applyHoverEffectToPosts();
    
        function applyHoverEffect(postElement) {
            postElement.addEventListener("mouseenter", function() {
                this.style.transform = "scale(1.03)";
                this.style.boxShadow = "0 0 16px rgba(0, 0, 0, 0.1)";
            });
            postElement.addEventListener("mouseleave", function() {
                this.style.transform = "scale(1)";
                this.style.boxShadow = "4px 4px 8px rgba(0, 0, 0, 0.1), -4px -4px 8px rgba(255, 255, 255, 0.5)";
            });
        }    
        
        function applyHoverEffectToPosts() {
            const posts = document.querySelectorAll(".post");
            posts.forEach(post => {
                addHoverEffect(post);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const userData = JSON.parse(localStorage.getItem('user'));
            if (userData) {
                const currentUsername = userData.identifier;
                fetchUserPosts(currentUsername);
                fetchAndDisplayFollowerCount(currentUsername);
            } else {
                console.error('User data not found in localStorage.');
            }
        });

        function loadModePreference() {
            const mode = localStorage.getItem('mode');
            if (mode === 'light') {
                document.body.classList.remove('dark-mode');
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
                document.body.classList.add('dark-mode');
            }
            console.log('Mode Loaded:', mode);
        }
        loadModePreference();
    
        window.onload = async function() {
    try {
        const userDataString = localStorage.getItem('user');
        if (!userDataString) {
            console.error('User data not found in localStorage.');
            return;
        }

        const userData = JSON.parse(userDataString);
        const identifier = userData.identifier;

        const response = await fetch(`/api/username`);
        const data = await response.json();
        const users = data.users;
        let currentUser = null;

        for (let i = 0; i < users.length; i++) {
            if (users[i].username === identifier) {
                currentUser = users[i];
                break;
            }
        }

        if (!currentUser) {
            console.error('User not found in the database.');
            return;
        }

        document.getElementById('profile-picture').src = currentUser.pb;
        document.getElementById('profile-username').innerText = currentUser.username;
        const profileUsernameElement = document.getElementById('profile-username');
        profileUsernameElement.textContent = `@${currentUser.username}`;

        // Anzeigen der Biografie im Profil
        const profileDescriptionElement = document.getElementById('profile-description');
        if (currentUser.bio) {
            profileDescriptionElement.innerText = currentUser.bio;
        } else {
            profileDescriptionElement.innerText = "‚ùå Bio not available";
        }
    } catch (error) {
        console.error("Error fetching user data:", error);
    }
};
    
        // Funktion zum Anzeigen des Overlays
        function showOverlay() {
            document.getElementById('overlay').classList.remove('hidden');
        }
    
        // Funktion zum Schlie√üen des Overlays
        function closeOverlay() {
            document.getElementById('overlay').classList.add('hidden');
        }
    
        // Funktion zum Speichern der Biografie
        async function saveBio() {
            try {
                // Neue Biografie aus dem Eingabefeld abrufen
                const newBio = document.getElementById('bio-input').value;

                if (newBio.trim() === '') {
                    return;
                }

                // Biografie-Anzeige im Profil aktualisieren
                document.getElementById('profile-description').innerText = newBio;
        
                // Benutzerdaten aus dem Local Storage abrufen
                const userData = JSON.parse(localStorage.getItem('user'));
                if (!userData) {
                    console.error('User data not found in localStorage.');
                    return;
                }
        
                // Benutzername und neue Biografie f√ºr die API-Anfrage vorbereiten
                const username = userData.identifier;
        
                // API-Anfrage senden, um die Biografie des Benutzers zu aktualisieren
                const response = await fetch('/api/update/bio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, newBio })
                });
        
                if (!response.ok) {
                    throw new Error('Failed to update bio.');
                }
        
                // Overlay schlie√üen
                closeOverlay();
            } catch (error) {
                console.error('Error saving bio:', error);
                // Hier k√∂nnen Sie eine Fehlermeldung anzeigen oder entsprechend reagieren
            }
        }

// Funktion zum Anzeigen der Zeichenanzahl und Anpassen der Farbe
function updateCharCount() {
    const bioInput = document.getElementById('bio-input');
    const charCountElement = document.getElementById('char-count');
    const remainingChars = 32 - bioInput.value.length;

    // √Ñndere die Farbe basierend auf der verbleibenden Zeichenanzahl
    if (remainingChars <= 10) {
        const redIntensity = Math.max(0, Math.min(255, remainingChars * 25));
        charCountElement.style.color = `rgb(255, ${redIntensity}, ${redIntensity})`;
    } else if (remainingChars <= 15) {
        charCountElement.style.color = 'white';
    } else {
        charCountElement.style.color = 'white'; // Standardfarbe
    }

    charCountElement.textContent = `${remainingChars} left`;
}

// Event-Listener f√ºr das Eingabefeld, um die Zeichenanzahl zu aktualisieren
document.getElementById('bio-input').addEventListener('input', updateCharCount);

        // Function to scroll to the top of the page with animation
        function scrollToTop() {
            const c = document.documentElement.scrollTop || document.body.scrollTop;
            if (c > 0) {
                window.requestAnimationFrame(scrollToTop);
                window.scrollTo(0, c - c / 8);
            }
        }

    window.onscroll = function() {
        scrollFunction();
    };
    
    function scrollFunction() {
        const scrollToTopButton = document.querySelector('.scroll-to-top');
        const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
        
        // Adjust the threshold value (50) to your desired scroll position before showing the button
        if (scrollPosition > 1200) {
            scrollToTopButton.style.display = "block";
        } else {
            scrollToTopButton.style.display = "none";
        }
    }

// PROFILBILD UPLOAD 

document.getElementById('profile-picture-upload').addEventListener('change', async function(event) {
    try {
        const file = event.target.files[0]; // Die ausgew√§hlte Datei aus dem Eingabefeld lesen
        if (!file) return;

        // √úberpr√ºfen, ob die Dateigr√∂√üe gr√∂√üer als 1 MB ist
        if (file.size > 1024 * 1024) {
            // Wenn die Dateigr√∂√üe gr√∂√üer als 1 MB ist, komprimiere das Bild
            const compressedFile = await compressImage(file);
            if (!compressedFile) return;
            uploadImage(compressedFile);
        } else {
            // Wenn die Dateigr√∂√üe kleiner oder gleich 1 MB ist, lade das Bild ohne Komprimierung hoch
            uploadImage(file);
        }
    } catch (error) {
        console.error('Error uploading profile picture:', error);
        // Hier k√∂nnen Sie eine Fehlermeldung anzeigen oder entsprechend reagieren
    }
});

async function compressImage(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                let maxSize = 100; // Maximale Breite und H√∂he f√ºr das Bild

                // √úberpr√ºfen, ob das Bild gr√∂√üer als maxSize x maxSize ist
                if (img.width > maxSize || img.height > maxSize) {
                    Toastify({
                        text: `Das Bild wird auf ${maxSize}x${maxSize} skaliert.`,
                        backgroundColor: 'linear-gradient(to right, #ff416c, #ff4b2b)',
                        className: 'info-toast'
                    }).showToast();

                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob((blob) => {
                        const compressedFile = new File([blob], file.name, { type: 'image/jpeg', lastModified: Date.now() });
                        resolve(compressedFile);
                    }, 'image/jpeg', 0.7); // 0.7 ist die Bildqualit√§t (0.0 - 1.0), √§ndern Sie dies nach Bedarf
                } else {
                    // Bild ist bereits kleiner als die maximale Gr√∂√üe, daher keine Komprimierung erforderlich
                    resolve(file);
                }
            };
        };
        reader.readAsDataURL(file);
    });
}

async function uploadImage(imageFile) {
    try {
        // Benutzerdaten aus dem Local Storage abrufen
        const userDataString = localStorage.getItem('user');
        if (!userDataString) {
            throw new Error('Benutzerdaten nicht im Local Storage gefunden.');
        }
        const userData = JSON.parse(userDataString);
        if (!userData || !userData.identifier) {
            throw new Error('Ung√ºltige Benutzerdaten im Local Storage.');
        }
        const username = userData.identifier;

        // Konvertieren des Bilds in einen Base64-codierten String
        const reader = new FileReader();
        reader.readAsDataURL(imageFile);
        reader.onload = async function () {
            const base64Image = reader.result;

            // Erstellen des JSON-Datenobjekts
            const jsonData = {
                username: username,
                newPB: base64Image,
            };

            const response = await fetch('/api/update/pb', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(jsonData),
            });

            if (!response.ok) {
                throw new Error('Fehler beim Aktualisieren des Profilbildes.');
            }

            Toastify({
                text: 'Profilbild erfolgreich aktualisiert.',
                duration: 3000,
                close: true,
                gravity: 'top', // Optionen: 'top', 'bottom', 'center'
                position: 'center', // Optionen: 'left', 'right', 'center'
                backgroundColor: 'linear-gradient(to right, #00b09b, #96c93d)',
            }).showToast();

            // Bild im Profil aktualisieren
            document.getElementById('profile-picture').src = base64Image;
        };
    } catch (error) {
        Toastify({
            text: 'Fehler beim Aktualisieren des Profilbildes: ' + error.message,
            duration: 3000,
            close: true,
            gravity: 'top', // Optionen: 'top', 'bottom', 'center'
            position: 'center', // Optionen: 'left', 'right', 'center'
            backgroundColor: 'linear-gradient(to right, #e74c3c, #e67e22)',
        }).showToast();
    }
}

// Funktion zum Abrufen und Anzeigen der Anzahl der Follower
async function fetchAndDisplayFollowerCount() {
    try {
        // Benutzerdaten aus dem Local Storage abrufen
        const userDataString = localStorage.getItem('user');
        if (!userDataString) {
            console.error('Benutzerdaten nicht im Local Storage gefunden.');
            return;
        }
        const userData = JSON.parse(userDataString);
        const username = userData.identifier;

        // API-Antwort mit Benutzerdaten abrufen
        const response = await fetch(`/api/profile/${username}`);
        const currentUser = await response.json();

        // √úberpr√ºfen, ob der aktuelle Benutzer gefunden wurde
        if (!currentUser) {
            console.error('Benutzer nicht in der API gefunden.');
            return;
        }

        // Anzahl der Benutzer, denen der aktuelle Benutzer folgt, abrufen
        const followingList = data.followers || []; // Liste der Benutzer, denen der aktuelle Benutzer folgt
        const followingCount = followingList.length; // Anzahl der Benutzer, denen der aktuelle Benutzer folgt
        
        // Namen der Benutzer, denen der aktuelle Benutzer folgt, anzeigen
        let followingNames = "";
        if (followingCount === 0) {
            followingNamesElement.textContent = "üò≠ No Followers";
        } else if (followingCount <= 3) {
            // Wenn es drei oder weniger Benutzer gibt, alle Namen anzeigen
            followingNames = followingList.join(", ");
        } else {
            // Wenn es mehr als drei Benutzer gibt, nur die ersten drei Namen anzeigen, gefolgt von "+10 andere"
            const firstThreeNames = followingList.slice(0, 3).join(", ");
            const remainingCount = followingCount - 3;
            followingNames = `${firstThreeNames} +${remainingCount} other`;
        }
        
        // Die angezeigten Namen in das HTML-Element einf√ºgen
        const followingNamesElement = document.getElementById('following-names');
        followingNamesElement.textContent = followingNames;

        // Anzahl der Follower des aktuellen Benutzers abrufen und anzeigen
        const followerCount = currentUser.follower || 0; // Falls kein Follower vorhanden ist, Standardwert 0 verwenden

        const followerCountElement = document.getElementById('follower-count');
        followerCountElement.textContent = followerCount;
    } catch (error) {
        console.error('Fehler beim Abrufen der Anzahl der Follower:', error);
    }
}
    </script>
</body>
</html>